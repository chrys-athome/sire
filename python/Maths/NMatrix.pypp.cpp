// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "NMatrix.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/array2d.hpp"

#include "SireBase/trigarray2d.hpp"

#include "SireError/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "matrix.h"

#include "nmatrix.h"

#include "nvector.h"

#include "sire_blas.h"

#include "sire_lapack.h"

#include "sire_linpack.h"

#include "trigmatrix.h"

#include "vector.h"

#include "nmatrix.h"

SireMaths::NMatrix __copy__(const SireMaths::NMatrix &other){ return SireMaths::NMatrix(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

void register_NMatrix_class(){

    { //::SireMaths::NMatrix
        typedef bp::class_< SireMaths::NMatrix > NMatrix_exposer_t;
        NMatrix_exposer_t NMatrix_exposer = NMatrix_exposer_t( "NMatrix", bp::init< >() );
        bp::scope NMatrix_scope( NMatrix_exposer );
        NMatrix_exposer.def( bp::init< int, int >(( bp::arg("nrows"), bp::arg("ncolumns") )) );
        NMatrix_exposer.def( bp::init< int, int, double >(( bp::arg("nrows"), bp::arg("ncolumns"), bp::arg("initial_value") )) );
        NMatrix_exposer.def( bp::init< SireMaths::Matrix const & >(( bp::arg("matrix") )) );
        NMatrix_exposer.def( bp::init< SireBase::Array2D< double > const & >(( bp::arg("array") )) );
        NMatrix_exposer.def( bp::init< QVector< QVector< double > > const & >(( bp::arg("array") )) );
        NMatrix_exposer.def( bp::init< SireMaths::Vector const &, bp::optional< bool > >(( bp::arg("vector"), bp::arg("transpose")=(bool)(false) )) );
        NMatrix_exposer.def( bp::init< QVector< double > const &, bp::optional< bool > >(( bp::arg("vector"), bp::arg("transpose")=(bool)(false) )) );
        NMatrix_exposer.def( bp::init< SireMaths::NVector const &, bp::optional< bool > >(( bp::arg("vector"), bp::arg("transpose")=(bool)(false) )) );
        NMatrix_exposer.def( bp::init< SireMaths::TrigMatrix const & >(( bp::arg("matrix") )) );
        NMatrix_exposer.def( bp::init< SireMaths::NMatrix const & >(( bp::arg("other") )) );
        { //::SireMaths::NMatrix::assertNColumns
        
            typedef void ( ::SireMaths::NMatrix::*assertNColumns_function_type )( int ) const;
            assertNColumns_function_type assertNColumns_function_value( &::SireMaths::NMatrix::assertNColumns );
            
            NMatrix_exposer.def( 
                "assertNColumns"
                , assertNColumns_function_value
                , ( bp::arg("ncolumns") ) );
        
        }
        { //::SireMaths::NMatrix::assertNRows
        
            typedef void ( ::SireMaths::NMatrix::*assertNRows_function_type )( int ) const;
            assertNRows_function_type assertNRows_function_value( &::SireMaths::NMatrix::assertNRows );
            
            NMatrix_exposer.def( 
                "assertNRows"
                , assertNRows_function_value
                , ( bp::arg("nrows") ) );
        
        }
        { //::SireMaths::NMatrix::assertSquare
        
            typedef void ( ::SireMaths::NMatrix::*assertSquare_function_type )(  ) const;
            assertSquare_function_type assertSquare_function_value( &::SireMaths::NMatrix::assertSquare );
            
            NMatrix_exposer.def( 
                "assertSquare"
                , assertSquare_function_value );
        
        }
        { //::SireMaths::NMatrix::assertValidColumn
        
            typedef void ( ::SireMaths::NMatrix::*assertValidColumn_function_type )( int ) const;
            assertValidColumn_function_type assertValidColumn_function_value( &::SireMaths::NMatrix::assertValidColumn );
            
            NMatrix_exposer.def( 
                "assertValidColumn"
                , assertValidColumn_function_value
                , ( bp::arg("j") ) );
        
        }
        { //::SireMaths::NMatrix::assertValidIndex
        
            typedef void ( ::SireMaths::NMatrix::*assertValidIndex_function_type )( int,int ) const;
            assertValidIndex_function_type assertValidIndex_function_value( &::SireMaths::NMatrix::assertValidIndex );
            
            NMatrix_exposer.def( 
                "assertValidIndex"
                , assertValidIndex_function_value
                , ( bp::arg("i"), bp::arg("j") ) );
        
        }
        { //::SireMaths::NMatrix::assertValidRow
        
            typedef void ( ::SireMaths::NMatrix::*assertValidRow_function_type )( int ) const;
            assertValidRow_function_type assertValidRow_function_value( &::SireMaths::NMatrix::assertValidRow );
            
            NMatrix_exposer.def( 
                "assertValidRow"
                , assertValidRow_function_value
                , ( bp::arg("i") ) );
        
        }
        { //::SireMaths::NMatrix::checkedOffset
        
            typedef int ( ::SireMaths::NMatrix::*checkedOffset_function_type )( int,int ) const;
            checkedOffset_function_type checkedOffset_function_value( &::SireMaths::NMatrix::checkedOffset );
            
            NMatrix_exposer.def( 
                "checkedOffset"
                , checkedOffset_function_value
                , ( bp::arg("i"), bp::arg("j") ) );
        
        }
        { //::SireMaths::NMatrix::column
        
            typedef ::SireMaths::NVector ( ::SireMaths::NMatrix::*column_function_type )( int ) const;
            column_function_type column_function_value( &::SireMaths::NMatrix::column );
            
            NMatrix_exposer.def( 
                "column"
                , column_function_value
                , ( bp::arg("j") ) );
        
        }
        { //::SireMaths::NMatrix::createColumnMajor
        
            typedef ::SireMaths::NMatrix ( *createColumnMajor_function_type )( int,int );
            createColumnMajor_function_type createColumnMajor_function_value( &::SireMaths::NMatrix::createColumnMajor );
            
            NMatrix_exposer.def( 
                "createColumnMajor"
                , createColumnMajor_function_value
                , ( bp::arg("nrows"), bp::arg("ncolumns") ) );
        
        }
        { //::SireMaths::NMatrix::createRowMajor
        
            typedef ::SireMaths::NMatrix ( *createRowMajor_function_type )( int,int );
            createRowMajor_function_type createRowMajor_function_value( &::SireMaths::NMatrix::createRowMajor );
            
            NMatrix_exposer.def( 
                "createRowMajor"
                , createRowMajor_function_value
                , ( bp::arg("nrows"), bp::arg("ncolumns") ) );
        
        }
        { //::SireMaths::NMatrix::determinant
        
            typedef double ( ::SireMaths::NMatrix::*determinant_function_type )(  ) const;
            determinant_function_type determinant_function_value( &::SireMaths::NMatrix::determinant );
            
            NMatrix_exposer.def( 
                "determinant"
                , determinant_function_value );
        
        }
        { //::SireMaths::NMatrix::diagonal
        
            typedef ::SireMaths::NVector ( ::SireMaths::NMatrix::*diagonal_function_type )(  ) const;
            diagonal_function_type diagonal_function_value( &::SireMaths::NMatrix::diagonal );
            
            NMatrix_exposer.def( 
                "diagonal"
                , diagonal_function_value );
        
        }
        { //::SireMaths::NMatrix::diagonalise
        
            typedef ::std::pair< SireMaths::NVector, SireMaths::NMatrix > ( ::SireMaths::NMatrix::*diagonalise_function_type )(  ) const;
            diagonalise_function_type diagonalise_function_value( &::SireMaths::NMatrix::diagonalise );
            
            NMatrix_exposer.def( 
                "diagonalise"
                , diagonalise_function_value );
        
        }
        { //::SireMaths::NMatrix::fullTranspose
        
            typedef ::SireMaths::NMatrix ( ::SireMaths::NMatrix::*fullTranspose_function_type )(  ) const;
            fullTranspose_function_type fullTranspose_function_value( &::SireMaths::NMatrix::fullTranspose );
            
            NMatrix_exposer.def( 
                "fullTranspose"
                , fullTranspose_function_value );
        
        }
        { //::SireMaths::NMatrix::inverse
        
            typedef ::SireMaths::NMatrix ( ::SireMaths::NMatrix::*inverse_function_type )(  ) const;
            inverse_function_type inverse_function_value( &::SireMaths::NMatrix::inverse );
            
            NMatrix_exposer.def( 
                "inverse"
                , inverse_function_value );
        
        }
        { //::SireMaths::NMatrix::isTransposed
        
            typedef bool ( ::SireMaths::NMatrix::*isTransposed_function_type )(  ) const;
            isTransposed_function_type isTransposed_function_value( &::SireMaths::NMatrix::isTransposed );
            
            NMatrix_exposer.def( 
                "isTransposed"
                , isTransposed_function_value );
        
        }
        { //::SireMaths::NMatrix::memory
        
            typedef ::QVector< double > ( ::SireMaths::NMatrix::*memory_function_type )(  ) const;
            memory_function_type memory_function_value( &::SireMaths::NMatrix::memory );
            
            NMatrix_exposer.def( 
                "memory"
                , memory_function_value );
        
        }
        { //::SireMaths::NMatrix::nColumns
        
            typedef int ( ::SireMaths::NMatrix::*nColumns_function_type )(  ) const;
            nColumns_function_type nColumns_function_value( &::SireMaths::NMatrix::nColumns );
            
            NMatrix_exposer.def( 
                "nColumns"
                , nColumns_function_value );
        
        }
        { //::SireMaths::NMatrix::nRows
        
            typedef int ( ::SireMaths::NMatrix::*nRows_function_type )(  ) const;
            nRows_function_type nRows_function_value( &::SireMaths::NMatrix::nRows );
            
            NMatrix_exposer.def( 
                "nRows"
                , nRows_function_value );
        
        }
        { //::SireMaths::NMatrix::offset
        
            typedef int ( ::SireMaths::NMatrix::*offset_function_type )( int,int ) const;
            offset_function_type offset_function_value( &::SireMaths::NMatrix::offset );
            
            NMatrix_exposer.def( 
                "offset"
                , offset_function_value
                , ( bp::arg("i"), bp::arg("j") ) );
        
        }
        NMatrix_exposer.def( bp::self != bp::self );
        { //::SireMaths::NMatrix::operator()
        
            typedef double const & ( ::SireMaths::NMatrix::*__call___function_type )( int,int ) const;
            __call___function_type __call___function_value( &::SireMaths::NMatrix::operator() );
            
            NMatrix_exposer.def( 
                "__call__"
                , __call___function_value
                , ( bp::arg("i"), bp::arg("j") )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        NMatrix_exposer.def( bp::self * bp::self );
        NMatrix_exposer.def( bp::self * bp::other< double >() );
        NMatrix_exposer.def( bp::self * bp::other< SireMaths::NVector >() );
        NMatrix_exposer.def( bp::self * bp::other< SireMaths::Vector >() );
        NMatrix_exposer.def( bp::self + bp::self );
        NMatrix_exposer.def( -bp::self );
        NMatrix_exposer.def( bp::self - bp::self );
        NMatrix_exposer.def( bp::self / bp::self );
        NMatrix_exposer.def( bp::self / bp::other< double >() );
        { //::SireMaths::NMatrix::operator=
        
            typedef ::SireMaths::NMatrix & ( ::SireMaths::NMatrix::*assign_function_type )( ::SireMaths::NMatrix const & ) ;
            assign_function_type assign_function_value( &::SireMaths::NMatrix::operator= );
            
            NMatrix_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        NMatrix_exposer.def( bp::self == bp::self );
        { //::SireMaths::NMatrix::redimension
        
            typedef void ( ::SireMaths::NMatrix::*redimension_function_type )( int,int ) ;
            redimension_function_type redimension_function_value( &::SireMaths::NMatrix::redimension );
            
            NMatrix_exposer.def( 
                "redimension"
                , redimension_function_value
                , ( bp::arg("nrows"), bp::arg("ncolumns") ) );
        
        }
        { //::SireMaths::NMatrix::reflectBottomLeftToTopRight
        
            typedef void ( ::SireMaths::NMatrix::*reflectBottomLeftToTopRight_function_type )(  ) ;
            reflectBottomLeftToTopRight_function_type reflectBottomLeftToTopRight_function_value( &::SireMaths::NMatrix::reflectBottomLeftToTopRight );
            
            NMatrix_exposer.def( 
                "reflectBottomLeftToTopRight"
                , reflectBottomLeftToTopRight_function_value );
        
        }
        { //::SireMaths::NMatrix::reflectBottomRightToTopLeft
        
            typedef void ( ::SireMaths::NMatrix::*reflectBottomRightToTopLeft_function_type )(  ) ;
            reflectBottomRightToTopLeft_function_type reflectBottomRightToTopLeft_function_value( &::SireMaths::NMatrix::reflectBottomRightToTopLeft );
            
            NMatrix_exposer.def( 
                "reflectBottomRightToTopLeft"
                , reflectBottomRightToTopLeft_function_value );
        
        }
        { //::SireMaths::NMatrix::reflectBottomToTop
        
            typedef void ( ::SireMaths::NMatrix::*reflectBottomToTop_function_type )(  ) ;
            reflectBottomToTop_function_type reflectBottomToTop_function_value( &::SireMaths::NMatrix::reflectBottomToTop );
            
            NMatrix_exposer.def( 
                "reflectBottomToTop"
                , reflectBottomToTop_function_value );
        
        }
        { //::SireMaths::NMatrix::reflectLeftToRight
        
            typedef void ( ::SireMaths::NMatrix::*reflectLeftToRight_function_type )(  ) ;
            reflectLeftToRight_function_type reflectLeftToRight_function_value( &::SireMaths::NMatrix::reflectLeftToRight );
            
            NMatrix_exposer.def( 
                "reflectLeftToRight"
                , reflectLeftToRight_function_value );
        
        }
        { //::SireMaths::NMatrix::reflectRightToLeft
        
            typedef void ( ::SireMaths::NMatrix::*reflectRightToLeft_function_type )(  ) ;
            reflectRightToLeft_function_type reflectRightToLeft_function_value( &::SireMaths::NMatrix::reflectRightToLeft );
            
            NMatrix_exposer.def( 
                "reflectRightToLeft"
                , reflectRightToLeft_function_value );
        
        }
        { //::SireMaths::NMatrix::reflectTopLeftToBottomRight
        
            typedef void ( ::SireMaths::NMatrix::*reflectTopLeftToBottomRight_function_type )(  ) ;
            reflectTopLeftToBottomRight_function_type reflectTopLeftToBottomRight_function_value( &::SireMaths::NMatrix::reflectTopLeftToBottomRight );
            
            NMatrix_exposer.def( 
                "reflectTopLeftToBottomRight"
                , reflectTopLeftToBottomRight_function_value );
        
        }
        { //::SireMaths::NMatrix::reflectTopRightToBottomLeft
        
            typedef void ( ::SireMaths::NMatrix::*reflectTopRightToBottomLeft_function_type )(  ) ;
            reflectTopRightToBottomLeft_function_type reflectTopRightToBottomLeft_function_value( &::SireMaths::NMatrix::reflectTopRightToBottomLeft );
            
            NMatrix_exposer.def( 
                "reflectTopRightToBottomLeft"
                , reflectTopRightToBottomLeft_function_value );
        
        }
        { //::SireMaths::NMatrix::reflectTopToBottom
        
            typedef void ( ::SireMaths::NMatrix::*reflectTopToBottom_function_type )(  ) ;
            reflectTopToBottom_function_type reflectTopToBottom_function_value( &::SireMaths::NMatrix::reflectTopToBottom );
            
            NMatrix_exposer.def( 
                "reflectTopToBottom"
                , reflectTopToBottom_function_value );
        
        }
        { //::SireMaths::NMatrix::row
        
            typedef ::SireMaths::NVector ( ::SireMaths::NMatrix::*row_function_type )( int ) const;
            row_function_type row_function_value( &::SireMaths::NMatrix::row );
            
            NMatrix_exposer.def( 
                "row"
                , row_function_value
                , ( bp::arg("i") ) );
        
        }
        { //::SireMaths::NMatrix::set
        
            typedef void ( ::SireMaths::NMatrix::*set_function_type )( int,int,double ) ;
            set_function_type set_function_value( &::SireMaths::NMatrix::set );
            
            NMatrix_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("j"), bp::arg("value") ) );
        
        }
        { //::SireMaths::NMatrix::setAll
        
            typedef void ( ::SireMaths::NMatrix::*setAll_function_type )( double ) ;
            setAll_function_type setAll_function_value( &::SireMaths::NMatrix::setAll );
            
            NMatrix_exposer.def( 
                "setAll"
                , setAll_function_value
                , ( bp::arg("value") ) );
        
        }
        { //::SireMaths::NMatrix::setColumn
        
            typedef void ( ::SireMaths::NMatrix::*setColumn_function_type )( int,double ) ;
            setColumn_function_type setColumn_function_value( &::SireMaths::NMatrix::setColumn );
            
            NMatrix_exposer.def( 
                "setColumn"
                , setColumn_function_value
                , ( bp::arg("j"), bp::arg("value") ) );
        
        }
        { //::SireMaths::NMatrix::setColumn
        
            typedef void ( ::SireMaths::NMatrix::*setColumn_function_type )( int,::SireMaths::NVector const & ) ;
            setColumn_function_type setColumn_function_value( &::SireMaths::NMatrix::setColumn );
            
            NMatrix_exposer.def( 
                "setColumn"
                , setColumn_function_value
                , ( bp::arg("j"), bp::arg("column") ) );
        
        }
        { //::SireMaths::NMatrix::setRow
        
            typedef void ( ::SireMaths::NMatrix::*setRow_function_type )( int,double ) ;
            setRow_function_type setRow_function_value( &::SireMaths::NMatrix::setRow );
            
            NMatrix_exposer.def( 
                "setRow"
                , setRow_function_value
                , ( bp::arg("i"), bp::arg("value") ) );
        
        }
        { //::SireMaths::NMatrix::setRow
        
            typedef void ( ::SireMaths::NMatrix::*setRow_function_type )( int,::SireMaths::NVector const & ) ;
            setRow_function_type setRow_function_value( &::SireMaths::NMatrix::setRow );
            
            NMatrix_exposer.def( 
                "setRow"
                , setRow_function_value
                , ( bp::arg("i"), bp::arg("row") ) );
        
        }
        { //::SireMaths::NMatrix::toString
        
            typedef ::QString ( ::SireMaths::NMatrix::*toString_function_type )(  ) const;
            toString_function_type toString_function_value( &::SireMaths::NMatrix::toString );
            
            NMatrix_exposer.def( 
                "toString"
                , toString_function_value );
        
        }
        { //::SireMaths::NMatrix::trace
        
            typedef double ( ::SireMaths::NMatrix::*trace_function_type )(  ) const;
            trace_function_type trace_function_value( &::SireMaths::NMatrix::trace );
            
            NMatrix_exposer.def( 
                "trace"
                , trace_function_value );
        
        }
        { //::SireMaths::NMatrix::transpose
        
            typedef ::SireMaths::NMatrix ( ::SireMaths::NMatrix::*transpose_function_type )(  ) const;
            transpose_function_type transpose_function_value( &::SireMaths::NMatrix::transpose );
            
            NMatrix_exposer.def( 
                "transpose"
                , transpose_function_value );
        
        }
        { //::SireMaths::NMatrix::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMaths::NMatrix::typeName );
            
            NMatrix_exposer.def( 
                "typeName"
                , typeName_function_value );
        
        }
        { //::SireMaths::NMatrix::what
        
            typedef char const * ( ::SireMaths::NMatrix::*what_function_type )(  ) const;
            what_function_type what_function_value( &::SireMaths::NMatrix::what );
            
            NMatrix_exposer.def( 
                "what"
                , what_function_value );
        
        }
        NMatrix_exposer.staticmethod( "createColumnMajor" );
        NMatrix_exposer.staticmethod( "createRowMajor" );
        NMatrix_exposer.staticmethod( "typeName" );
        NMatrix_exposer.def( "__copy__", &__copy__);
        NMatrix_exposer.def( "__deepcopy__", &__copy__);
        NMatrix_exposer.def( "clone", &__copy__);
        NMatrix_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMaths::NMatrix >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        NMatrix_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMaths::NMatrix >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        NMatrix_exposer.def( "__str__", &__str__< ::SireMaths::NMatrix > );
        NMatrix_exposer.def( "__repr__", &__str__< ::SireMaths::NMatrix > );
    }

}
